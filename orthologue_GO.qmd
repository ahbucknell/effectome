---
title: "Analysis GO terms of structural orthologues"
engine: julia
---

IBM colour scheme.

This analysis focuses on extracting GO terms from PDB entries identified as structural orthologues of a Mep through Foldseek. It uses REST APIs to:

1. Gather all UniProt IDs associated with a PDB entry, and resolves obsolete PDB entries.

2. Gather all GO terrms associated with a UniProt ID, and skips IDs that have been deleted from UniProtKB.

3. Gathers metadata (description + aspect) of each GO term.



## Setup
```{julia}
using CSV, DataFrames, PhyloNetworks
dir = expanduser(joinpath("~", "oneDrive", "projects", "effectome", "datasets"))
fsRaw = CSV.read(joinpath(dir, "foldseek.tsv"), DataFrame, delim = "\t", header = false)
sort!(fsRaw, :Column11)
grpByMGG = groupby(fsRaw, :Column1)
topHits = combine(first, grpByMGG)

tree = readnewick(joinpath(dir, "50_avg-pLDDT_rooted.nwk"))
nodes = tiplabels(tree)
filter!(row -> row.Column1 in nodes, topHits)
pdb = unique(uppercase.(getindex.(split.(topHits.Column2, "-"),1)))
```

## Obtaining UniProt IDs from PDB ID
```{julia}
using HTTP, JSON3

function checkObsoleteID(pdbID)
    url = "https://www.rcsb.org/structure/removed/$pdbID"
    body = try
        response = HTTP.get(url)
        body = String(response.body)
    catch err
        println("Could not access the page. Error: $err")
        return nothing
    end
    if !isnothing(body)
        m = match(r"\/structure\/[A-Z0-9]+", body)
        newPDB = split(m.match , "/")[end]
        println("$pdbID is obselete. New PDB ID is: $newPDB")
        return newPDB
    else
        return nothing
    end
end

function pdbToUniprot(pdbID)
    url = "https://data.rcsb.org/rest/v1/core/polymer_entity/$pdbID/1"
    try
        response = HTTP.get(url)
        body = JSON3.read(String(response.body))
        allIdentifiers = body.rcsb_polymer_entity_container_identifiers
        if :uniprot_ids in collect(keys(allIdentifiers))
            return allIdentifiers.uniprot_ids
        else
            println("$pdbID has no associated UniProt ID")
            return nothing
        end
    catch err
        println("API fetch failed for $pdbID\nChecking if obsolete...")
        tmp = checkObsoleteID(pdbID)
        if !isnothing(tmp)
            pdbToUniprot(tmp)
        else
            return nothing
        end
    end
end

uniprotIDs = Dict()
for elem in pdb
    tmpIDs = pdbToUniprot(elem)
    uniprotIDs[elem] = tmpIDs
end

```

Given our list of PDB IDs, we want to find the associated UniProt ID(s) for each PDB ID. We're achieving this through the `pdbToUniprot` function which utilises the PDB's REST API to query each PDB ID individually. There are four possible outcomes:

1. The PDB ID is found in the PDB, and there is/are associated UniProt ID(s). The return is a vector of the UniProt ID(s).

2. The PDB ID is found in the PDB, but there are no associated UniProt IDs. Most likely due to the PDB entry being a synthetic structure not found in nature. The return is `nothing`.

3. The PDB ID is **not** found in the PDB, most likely because it is obsolete. The `checkObsoleteID` function is run returning the new PDB ID to run `pdbToUniprot` on.

4. The PDB ID is **not** found in the PDB. The `checkObsoleteID` function is run, but no new PDB ID can be found. The return is `nothing`.

It's worth noting that currently the best way to query the failed associations is through filtering by `nothing`, however this will lump those failing by outcome 2 and 4 together. In this dataset, outcome 4 does not occur (AFAIK) so there is no need to alter the function. However, you might want to alter the `pdbToUniprot` and `checkObsoleteID` functions to split them if you see significant failures by both outcomes.

## Obtaining GO terms from UniProt ID
```{julia}
function uniprotToGO(uniprotID)
    url = "https://rest.uniprot.org/uniprotkb/$uniprotID.json"
    try
        response = HTTP.get(url, ["Accept-Encoding" => "identity"])
        body = JSON3.read(String(response.body))
        crossRefs = body.uniProtKBCrossReferences
        tmpGOs = []
        for x in crossRefs
            if x.database == "GO"
                push!(tmpGOs, x.id)
            end
        end
        return tmpGOs
    catch err
        println("API fetch failed for $uniprotID")
        return nothing
    end
end

goTerms = Dict()

# uniprotIDs is a PDB:UniProt dictionary, with nothing as some values.
# We need to filter the nothing values out for input into uniprotToGO()
uniprots = filter(x -> !isnothing(last(x)), uniprotIDs)

for x in uniprots
    tmpGOs = []
    for y in last(x)
        tmp = uniprotToGO(y)
        if !isnothing(tmp)
            append!(tmpGOs, tmp)
        else
            tmpGOs = nothing
        end
    end
    goTerms[first(x)] = tmpGOs
end
```

Here, we're finding all associated GO terms for each UniProt ID through the `uniprotToGO` function. There are three possible outcomes:

1. The UniProt ID is found in UniProtKB, and there are associated GO terms. The return is a vector of GO terms.

2. The UniProt ID is found in the UniProtKB, but there are **no** associated GO terms. The return is a zero-length vector.

3. The UniProt ID is **not** found in the UniProtKB, most likely as it's no longer annotated. The return is `nothing`.

The final output here is the `goTerms` dictionary, which links PDB ID (key) to an array of associated GO terms (value). In the case of multiple UniProt IDs, more than one outcome can be true at once. So if the first UniProt ID had associated GO terms but the second didn't, then the return is an array of just the GO terms from the first ID. Similarily, if the first UniProt ID had associated GO terms but the second was deleted from UniProtKB then the return is an array of GO terms including a `nothing` element.

## Plotting analysis metadata
```{julia}
using CairoMakie, Colors

IDAfig = Figure()

# Total unique PDB IDs
totalPDB = length(pdb)
# PDB IDs without associated UniProt IDs
totalWoUniprot = length(filter(x -> isnothing(last(x)), uniprotIDs))
# PDB IDs with associated UniProt IDs that have been removed from UniProtKB
totalDelUniprot
# PDB IDs with associated UniProt IDs
totalWithUniprot

nothingCount = sum([count(isnothing, x) for x in values(goTerms)])

IDAplotData = (x = [],
               y = [],
               z = [])

barplot([1,2], [length(uniprotIDs), length(uniprotMissing)],
        axis = (xticks = ([1,2],["Associated", "Missing"]),
                xlabel = "UniProt IDs associated to PDB", ylabel = "Count", aspect = 1),
        color = [colorant"rgb(100,143,255)", colorant"rgb(220,38,127)"],
        strokewidth = 1)
```


## Obtaining GO term metadata
```{julia}
using DataFrames

goList = collect(values(goTerms))
filter!(x -> !isnothing(x), goList)
goFreqs = countmap(collect(Iterators.flatten(goList)))

goData = DataFrame(GO = collect(keys(goFreqs)),
                   freq = collect(values(goFreqs)))


function getGoInfo(got)
    url = "https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/$got"
    try
        response = HTTP.get(url)
        body = JSON3.read(String(response.body))
        if body.numberOfHits > 1
            println("More than one result for $got")
            println(got)
        end
        result = body.results[1]
        if result.isObsolete == true
            return nothing, nothing
        else
            return result.name, result.aspect
        end
    catch e
        println(e)
    end

end

goMetadata = [getGoInfo(x) for x in goData.GO]
goData.desc = getindex.(goMetadata, 1)
goData.aspect = getindex.(goMetadata, 2)

goBP = filter(:aspect => x -> x == "biological_process", goData)
goCC = filter(:aspect => x -> x == "cellular_component", goData)
goMF = filter(:aspect => x -> x == "molecular_function", goData)

sort!(goBP, :freq, rev = true)
sort!(goCC, :freq, rev = true)
sort!(goMF, :freq, rev = true)
```


```{julia}
BP = barplot(10:-1:1, goBP.freq[1:10],direction= :x,
        axis = (title = "BP",
                yticks = (10:-1:1, goBP.desc[1:10])))

CC = barplot(10:-1:1, goCC.freq[1:10],direction= :x,
        axis = (title = "CC",
                yticks = (10:-1:1, goCC.desc[1:10])))

MF = barplot(10:-1:1, goMF.freq[1:10],direction= :x,
        axis = (title = "CC",
                yticks = (10:-1:1, goMF.desc[1:10])))
```