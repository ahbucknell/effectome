---
title: "GO term analysis"
engine: julia
---

This analysis focuses on extracting GO terms from PDB entries identified as structural orthologues to at least one Mep. Structural orthologues were identified via [Foldseek](https://doi.org/10.1038/s41587-023-01773-0). This analysis uses REST APIs to:

1. Gather all UniProt IDs associated with a PDB entry, and resolves obsolete PDB entries.

2. Gather all GO terrms associated with a UniProt ID, and skips IDs that have been deleted from UniProtKB.

3. Gathers metadata (description + aspect) of each GO term.

Plots are then generated for each GO term aspect, showing the most frequent 10 terms.

## Setup
```{julia}
using Pkg
Pkg.activate(@__DIR__)
Pkg.instantiate()
using CSV, DataFrames, PhyloNetworks, HTTP, JSON3, StatsBase, CairoMakie
```
We initially want to load the Julia project containing dependent modules. The Julia project can take a while to load and contains all modules required for all Julia scripts in this repository.

## Filtering PDBs
```{julia}
dir = expanduser(joinpath("~", "oneDrive", "projects", "effectome", "datasets"))
fsRaw = CSV.read(joinpath(dir, "foldseek.tsv"), DataFrame, delim = "\t", header = false)
sort!(fsRaw, :Column11)
grpByMGG = groupby(fsRaw, :Column1)
topHits = combine(first, grpByMGG)
filter!(:Column11 => x -> x < 0.01, topHits)

tree = readnewick(joinpath(dir, "50_avg-pLDDT_rooted.nwk"))
nodes = tiplabels(tree)
filter!(row -> row.Column1 in nodes, topHits)
pdb = unique(uppercase.(getindex.(split.(topHits.Column2, "-"),1)))
println(length(pdb), " PDB IDs found.")
```

The PDBs are filtered by E-value and by associtated MGGs being within the tree.

## Obtaining UniProt IDs from PDB ID
```{julia}
function checkObsoleteID(pdbID)
    url = "https://www.rcsb.org/structure/removed/$pdbID"
    body = try
        response = HTTP.get(url)
        body = String(response.body)
    catch err
        println("Could not access the page. Error: $err")
        return nothing
    end
    if !isnothing(body)
        m = match(r"\/structure\/[A-Z0-9]+", body)
        newPDB = split(m.match , "/")[end]
        println("$pdbID is obselete. New PDB ID is: $newPDB")
        return newPDB
    else
        return nothing
    end
end

function pdbToUniprot(pdbID)
    url = "https://data.rcsb.org/rest/v1/core/polymer_entity/$pdbID/1"
    try
        response = HTTP.get(url)
        body = JSON3.read(String(response.body))
        allIdentifiers = body.rcsb_polymer_entity_container_identifiers
        if :uniprot_ids in collect(keys(allIdentifiers))
            return allIdentifiers.uniprot_ids
        else
            println("$pdbID has no associated UniProt ID")
            return nothing
        end
    catch err
        println("API fetch failed for $pdbID\nChecking if obsolete...")
        tmp = checkObsoleteID(pdbID)
        if !isnothing(tmp)
            pdbToUniprot(tmp)
        else
            return nothing
        end
    end
end

uniprotPath = joinpath(@__DIR__, "_output", "data", "structural_orthologues_Uniprot_IDs.csv")

# API calls only run if UniProt IDs are not already written to file.
if isfile(uniprotPath) == true
    uniprotDF = CSV.read(uniprotPath, DataFrame)
    uniprotDict = Dict(key.pdb => df.uniprot
        for (key, df) in pairs(groupby(uniprotDF, :pdb)))
else
    uniprotDict = Dict()
    for elem in pdb
        tmpIDs = pdbToUniprot(elem)
        uniprotDict[elem] = tmpIDs
    end
    filter!(x -> !isnothing(last(x)), uniprotDict)
    uniprotDF = DataFrame(
        pdb = [key for (key, val) in uniprotDict for x in val],
        uniprot = collect(Iterators.flatten(values(uniprotDict))))
    CSV.write(uniprotPath, uniprotDF)
end
```

Given our list of PDB IDs, we want to find the associated UniProt ID(s) for each PDB ID. We're achieving this through the `pdbToUniprot` function which utilises the PDB's REST API to query each PDB ID individually. There are four possible outcomes:

1. The PDB ID is found in the PDB, and there is/are associated UniProt ID(s). The return is a vector of the UniProt ID(s).

2. The PDB ID is found in the PDB, but there are no associated UniProt IDs. Most likely due to the PDB entry being a synthetic structure not found in nature. The return is `nothing`.

3. The PDB ID is **not** found in the PDB, most likely because it is obsolete. The `checkObsoleteID` function is run returning the new PDB ID to run `pdbToUniprot` on.

4. The PDB ID is **not** found in the PDB. The `checkObsoleteID` function is run, but no new PDB ID can be found. The return is `nothing`.

It's worth noting that currently the best way to query the failed associations is through filtering by `nothing`, however this will lump those failing by outcome 2 and 4 together. In this dataset, outcome 4 does not occur (AFAIK) so there is no need to alter the function. However, you might want to alter the `pdbToUniprot` and `checkObsoleteID` functions to split them if you see significant failures by both outcomes.

## Obtaining GO terms from UniProt ID

```{julia}
function uniprotToGO(uniprotID)
    url = "https://rest.uniprot.org/uniprotkb/$uniprotID.json"
    try
        response = HTTP.get(url, ["Accept-Encoding" => "identity"])
        body = JSON3.read(String(response.body))
        crossRefs = body.uniProtKBCrossReferences
        tmpGOs = []
        for x in crossRefs
            if x.database == "GO"
                push!(tmpGOs, x.id)
            end
        end
        return tmpGOs
    catch err
        println("API fetch failed for $uniprotID")
        return nothing
    end
end

goTerms = Dict()
for x in uniprotDict
    tmpGOs = []
    for y in last(x)
        tmp = uniprotToGO(y)
        if !isnothing(tmp)
            append!(tmpGOs, tmp)
        else
            tmpGOs = nothing
        end
    end
    goTerms[first(x)] = tmpGOs
end
```

Here, we're finding all associated GO terms for each UniProt ID through the `uniprotToGO` function. There are three possible outcomes:

1. The UniProt ID is found in UniProtKB, and there are associated GO terms. The return is a vector of GO terms.

2. The UniProt ID is found in the UniProtKB, but there are **no** associated GO terms. The return is a zero-length vector.

3. The UniProt ID is **not** found in the UniProtKB, most likely as it's no longer annotated. The return is `nothing`.

The final output here is the `goTerms` dictionary, which links PDB ID (key) to an array of associated GO terms (value). In the case of multiple UniProt IDs, more than one outcome can be true at once. So if the first UniProt ID had associated GO terms but the second didn't, then the return is an array of just the GO terms from the first ID. Similarily, if the first UniProt ID had associated GO terms but the second was deleted from UniProtKB then the return is an array of GO terms including a `nothing` element.

## Obtaining GO term metadata
```{julia}
goList = collect(values(goTerms))
filter!(x -> !isnothing(x), goList)
goFreqs = countmap(collect(Iterators.flatten(goList)))
goData = DataFrame(GO = collect(keys(goFreqs)),
                   freq = collect(values(goFreqs)))

function getGoInfo(got)
    url = "https://www.ebi.ac.uk/QuickGO/services/ontology/go/terms/$got"
    try
        response = HTTP.get(url)
        body = JSON3.read(String(response.body))
        if body.numberOfHits > 1
            println("More than one result for $got")
            println(got)
        end
        result = body.results[1]
        if result.isObsolete == true
            return nothing, nothing
        else
            return result.name, result.aspect
        end
    catch e
        println(e)
    end
end

goMetadata = [getGoInfo(x) for x in goData.GO]
goData.desc = getindex.(goMetadata, 1)
goData.aspect = getindex.(goMetadata, 2)
filter!(row -> all(!isnothing, values(row)), goData)
goData.desc = [length(s) > 40 ? s[1:37] * "..." : s for s in goData.desc]

goBP, goCC, goMF = map(["biological_process", "cellular_component", "molecular_function"]) do aspect
    df = filter(:aspect => x -> x == aspect, goData)
    sort!(df, :freq, rev = true)
end
```

## GO term plots
```{julia}
titles = Dict(goBP => "BP", goCC => "CC", goMF => "MF")
for df in [goBP, goCC, goMF]
    f = Figure()
    ax = Axis(f[1,1], yticks = (10:-1:1, df.desc[1:10]),
              xlabel = "Frequency", title = titles[df])
    barplot!(ax, 10:-1:1, df.freq[1:10], direction= :x,
             color = colorant"rgb(100,143,255)", strokewidth = 1)
    display(f)
end
```

## Plotting analysis metadata
```{julia}
#IDAfig = Figure()#
#



totalPDB = length(pdb)
woUniprot = totalPDB - length(uniprotDict)
wDelUniprot = length(filter(x -> !isnothing(last(x)), goTerms))
wUniprot = totalPDB - (woUniprot + )

length(filter(x -> !isnothing(last(x)), goTerms))

# Total unique PDB IDs
# PDB IDs without associated UniProt IDs
# PDB IDs with associated UniProt IDs that have been removed from UniProtKB
# PDB IDs with associated UniProt IDs



#nothingCount = sum([count(isnothing, x) for x in values(goTerms)])

#IDAplotData = (x = [],
#               y = [],
#               z = [])

#barplot([1,2], [length(uniprotDict), length(uniprotMissing)],
#        axis = (xticks = ([1,2],["Associated", "Missing"]),
#                xlabel = "UniProt IDs associated to PDB", ylabel = "Count", aspect = 1),
#        color = [colorant"rgb(100,143,255)", colorant"rgb(220,38,127)"],
#        strokewidth = 1)
```